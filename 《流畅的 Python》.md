
元类(metaclass)、静态方法和类方法、字典推导式、单下划线和双下划线、迭代器和生成器、装饰器、\_\_new__ 和 \_\_init__、作用域、闭包、copy 和 deepcopy、垃圾回收机制、== 和 is、

### 第1章 Python数据模型  

访问属性，调用方法的时候，就会调用 \_\_getitem__ ,   

for 循环背后调用的是 iter(), 背后是 \_\_iter__    

\_\_repr__ 的作用是实现字符串现实形式  

占位符 % 和 .format() 背后用的就是 \_\_repr__  

使用 if while and or 这些的时候，会调用 bool() 进行判断  




### 第7章 函数装饰器和闭包  

装饰器是函数  




### 第8章 对象引用、可变性和垃圾回收  

为了理解 Python 中的赋值语句，应该始终先读右边。对象在右边创建或获取，然后为对象贴贴纸  

对象一旦建立，标识就不会再变，就是 id，就是内存地址，就是身份证  

is 比较的是地址，是身份证号; == 比较的是值，是名字  

元组如果有可变的元素，那么元组元素是可变的，元组不可变说的是元组的标识不会变  

浅复制，复制了最外层容器，副本中的元素是源容器中元素的引用  

    l1 = [3, [66, 55, 44], (7, 8, 9)] 
    l2 = list(l1)   # 执行以后，l1 和 l2 指代不同的列表，但是两个列表引用的是相同的列表 [66, 55, 44] 和元组 (7, 8, 9)  
    l1.append(100) 
    l1[1].remove(55) 
    print('l1:', l1) 
    print('l2:', l2)
    l2[1]+= [33, 22] 
    l2[2]+= (10, 11) 
    print('l1:', l1) 
    print('l2:', l2)

在 [pythontutor](http://www.pythontutor.com/live.html#mode=edit) 上跑一遍就完全明白什么是深复制，什么是浅复制了  






## 其他  

python 自省就是运行时能够获得对象的类型。比如type()，dir()，getattr()，hasattr()，isinstance()  

字典推导式 

    d = {key: value for (key, value) in iterable}
    
GIL 对于 IO 密集型，python 多线程会提高速度，但是对于 CPU 密集型，很可能会降低速度  


