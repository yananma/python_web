
抄的时候思考程序做的是什么，靠背是背不下来的，拘泥于编程语言细节反而是有害的，理解了思想，用程序来实现思想    

中序遍历二叉树的递归算法 5 遍  
中序遍历二叉树的非递归算法 5 遍  

顺序查找 5 遍。逐个对比  
二分查找 5 遍。每次查找缩小一半范围  
冒泡排序 6 遍。两两相比，大的后移    
快速排序 5 遍。选取中心，调整顺序  
调整堆、建初堆、堆排序 5 遍。堆顶就是最值，弹出堆顶，再调整剩余的元素为根堆，再弹出堆顶元素。每次选一个最值，所以是选择排序    


# 抄 5 遍，不行就再抄 5 遍，多抄几次就学会了，就是这么简单  

初始条件、数据对象、操作、操作结果  

    class 类名称:  
        数据对象  
        基本操作(参数)
            初始条件
            操作
            return 操作结果  


p = p.next 指针后移
l1.next = l2 l2 接到 l1 的后面  

## 线性表  

单链表的插入  
s->next = p->next 的意思就是把 p 的 next 指针域指向的节点接到 s 后面  
p->next = s s 节点接到 p 的后面  

new 申请一块空间  
delete 删除元素，释放空间  


传值方式，修改的是副本，原来的没有任何改变  
传址方式，只有一套，没有副本，修改了就是都修改了  

&j = i，&是引用，指向的是同一个东西，j 改变的时候，i 也会改变  

    int main() {
      int i = 3; 
      int &j = i; 
      j++; 
      return 0;
    }

在 [pythontutor](http://www.pythontutor.com/cpp.html#mode=edit) 上跑一下就全都明白了  




## 串、数组和广义表  

KMP  

字符串的前缀和后缀。如果字符串 A 和 B，存在 A = BS，其中 S 是任意的非空字符串，那就称 B 为 A 的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀 A = SB， 其中 S 是任意的非空字符串，那就称 B 为 A 的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。

有了这个定义，就可以说明 PMT 中的值的意义了。PMT 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度。例如，对于”aba”，它的前缀集合为{”a”, ”ab”}，后缀 集合为{”ba”, ”a”}。两个集合的交集为{”a”}，那么长度最长的元素就是字符串”a”了，长度为 1，所以对于”aba”而言，它在 PMT 表中对应的值就是 1。再比如，对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为 3。


书上算法中，不匹配为 1  

算的是 k-1，比如有一个字符匹配，k-1=1，k=2  


## 树和二叉树  

先序后序定根，中序定左右  

根据遍历结果生成了树以后，要再遍历一遍，检查对不对  





#### 指针，指针就是地址，就是门牌号    
int num1 = 10  

cout << num1 << endl; 结果是 10  

& 是取址运算符，得到变量所在的地址，用法是 & 变量名称，比如 &num1 是地址  

cout << &num1 << endl; 结果是 0x6ffe30  

指针变量就是用来存储内存地址的变量，和 &变量名称 完全等价，就是不用多写一个符号了     

p = & num1，p 指针存的也是地址  

\* 是取值运算符  

\*p 就是取指针指向空间的内容    

\*p=20，就是重新赋值  





