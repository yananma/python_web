
```python
In [23]: l=[]

In [24]: l.__sizeof__()  // 空列表分配了40字节的内存
Out[24]: 40

In [25]: l.append('a')  // 增加了一个一个元素后，给列表分配了72字节的内存，一个字符8个字节，那就是一次性分配了4个字符的内存空间

In [26]: l.__sizeof__()
Out[26]: 72

In [27]: l.append('b')  // 再增加字符，占用内存不变

In [28]: l.__sizeof__()
Out[28]: 72

In [29]: l.append('c')  // 再增加字符，占用内存不变

In [30]: l.__sizeof__()
Out[30]: 72

In [31]: l.append('d')  // 再增加字符，占用内存不变

In [32]: l.__sizeof__()
Out[32]: 72

In [33]: l.append('e')  // 再添加元素，内存不够，触发重新的内存分配

In [34]: l.__sizeof__()
Out[34]: 104
```
可以看出list为了能够实时追踪内存的使用情况，当空间不足时以及分配额外空间，额外的多分配了内存，而且还需要存储指针，指向对应的元素。

我们可以看到，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。

所以说在存储大量的数据的时候，这种差异是需要考虑的，如果数据发生变更的可能性不大，就用元组存储，如果数据是需要频繁的进行数据的修改增加，就使用列表

