

# HTTP 协议  

HTTP 短连接，比如打开百度，看到百度页面的时候，其实是没有连接的，因为如果所有的显示都连接，百度的服务器承受不了，看到的只是返回结果  

短连接是在 socket 中，最后的 conn.close() 实现的，实现以后，还是 True，还会在服务端等待连接    

### 第 1 章 HTTP 概述  

Web 浏览器、服务器和相关的 Web 应用程序都是通过 HTTP 相互通信的。HTTP 是现代全球互联网中使用的公共语言。  

HTTP 使用的是可靠的数据传输协议  

Web 内容都是存储在 Web 服务器上的，Web 服务器是 Web 资源的宿主(电脑和文件)  

媒体类型 MIME Multipurpose Internet Mail Extension 多用途因特网邮件拓展  

Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型（文件格式）  

每个 Web 服务器资源都有一个名字，这样客户端就能找到特定的资源了。服务器资源名称被称为统一资源标识符(Uniform Resource Identifier URI)  

给定了 URI，HTTP 就可以解析出对象  

**URL 就是找资源用的，就是资源地址**

统一资源定位符(URL)描述了一台特定服务器上某资源的特定位置，可以明确说明如何从一个精确、固定的位置获取资源(比如 course detail 和 blog detail 的 ?id，找的就是特定的资源，? 是查询，比如分类)  

请求 request，说明要找的资源是什么，比如 GET /logo.gif HTTP/1.1；response 就是展示出图片   

每条报文都包含一个方法，方法会告诉服务器执行什么操作。常用方法：GET、POST、PUT、DELETE  

GET 从服务器取资源  

POST 从客户端向服务器发送要处理的数据  

PUT 将请求的主体部分存储在服务器上  

每条报文都会携带一个状态码  

一个 HTTP 事务由一条客户端发向服务器的请求命令和一个从服务器发回客户端的响应结果组成。  

应用程序完成一项任务通常会发布多个 HTTP 事务，这些资源可能都不在一个服务器上。(Nginx 静态文件，uwsgi 动态文件)  

HTTP 是基于 TCP 的，TCP 连接是可靠的传输协议  

TCP 连接需要知道 IP 地址和服务器上运行的特定软件的端口号。(端口号的作用是用来找应用程序的，这就是阿里云安全组的意义，也是 Nginx 配置端口号的意义)  

怎么知道 IP 地址和端口号呢？当然是通过 URL 了，URL 就是资源地址  

没有端口号的时候，是 80 端口，所以还是有端口的；有了 IP 有了端口，本质上还是建立 TCP 连接  

Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此 TCP 端口的输出送回到显示屏上。可以通过 Telnet 程序直接与 Web 服务器进行对话，Web 服务器会将 Telnet 程序作为一个 Web 客户端来处理，所有送回 TCP 连接的数据都会显示在屏幕上  

Telnet 可以很好地模拟客户端  

* 代理  
代理位于客户端和服务器之间，接受所有客户端的 HTTP 请求，并将这些请求转发给服务器，代表用户访问服务器   

* 缓存  
缓存就是副本；但是一直不用的，会一直占用资源，所以有过期时间  
Web 缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以使用缓存副本提供的服务了；使用客户端附近的缓存要比从远程 Web 服务器快得多  

* 网关  
网关(gateway) 是一种特殊的服务器，常用于将 HTTP 流量转换成其他的协议，客户端可能并不知道自己正在和一个网关进行通信。  

比如客户端发送 HTTP 请求到网关，网关向 FTP 服务器发送 FTP 请求，FTP 发回文件，网关将其封装成 HTTP 报文，发送给客户端  



### 第 2 章 URL 与资源  

URL 就是资源位置  

scheme、主机和资源路径  

URL 路径说明了资源位于服务器的什么地方，本质上就是服务器的文件系统路径  


### 第 3 章 HTTP 报文  

理解了报文就可以编写自己的 HTTP 应用程序  

就是 start line、header、body  

Content-Type 说明了 body 是什么 MIME 格式，比如 text/html  

Content-Length 说明了 body 的大小，单位是字节。一个字节是 8 位     

请求报文起始行说明了要做什么，响应报文起始行说明发生了什么  

请求要指明 HTTP 版本号，以便互相了解对方的能力和报文格式  

首部分为通用首部(既可以出现在请求报文中，也可以出现在响应报文中)、请求首部(请求特有的，提供更多请求的信息，比如 accept 首部)、响应首部(响应特有的，提供更多有关响应的信息)  

主体 body 是 HTTP 要传输的内容，类型包括：图片、视频、HTML文档等  

* GET 方法是最常用的方法，通常用于请求服务器发送某个资源  

* HEAD 方法只返回首部，不返回 body  

* PUT 方法向服务器写入文档，比如 PUT /a.txt HTTP/1.1 会返回 201 created  

* POST 起初是用来想服务器输入数据的(POST 用于向服务器发送数据，POST 用户名密码，PUT 用于向服务器上的资源比如文件中存储数据，PUT a.txt)，现在通常用来支持 HTML 表单  

* TRACE 可以看中间经历过程，比如代理等  

* OPTIONS 返回 Allow 首部，显示服务器支持的方法  



状态码提供了一种理解处理结果的便捷方式  

* 100-199 信息性状态码  

* 200-299 成功状态码  

* 300-399 重定向状态码  

* 400-499 客户端错误状态码  

* 500-599 服务器错误状态码  

404 错误是最常见的错误，客户端请求的是一个不存在的 URL  


通用首部，比如时间 Date    

Greenwich Mean Time(GMT)格林威治时间，北京时间=GMT+8  

Cache-Control 缓存指示  

请求首部，说明是谁或什么在发送请求，请求源自何处，或者客户端可以接受的格式，服务器可以根据这些提供更好的响应  

Accept 首部，对客户端和服务器都是有益的，服务器不用浪费时间发送无用的格式；比如 Accept-Charset、Accept-Encoding、Accept-Language  

Host 是要请求的服务器的 IP 和端口  

响应首部，有助于客户端处理响应，并在将来发送更好的请求  

Server 服务器应用程序软件名称和版本，比如访问自己的网站的时候，Server 是 nginx/1.18.0 (Ubuntu)，说明浏览器确实是在和 Nginx 交互的，Nginx 在 uwsgi 前面  


实体首部，实体首部提供了有关实体及其内容的大量信息  

Content-Length、Content-Type、Content-Encoding  


### 第 4 章 连接管理  

客户端可以通过 TCP/IP 连接到世界上任何地方的服务器应用程序，而且是可靠的连接，不会有报文丢失  

先将 IP 地址和端口号从 URL 中分离出来，然后建立 TCP 连接，然后发送一条 GET 报文，收到响应，关闭连接  

HTTP 连接实际上就是 TCP 连接及其使用规则  

Connection：keep-alive 事务结束以后 TCP 依然保持连接，不用每次都再握手连接  


有时连接中间关闭，事务没有处理完，客户端无法确认处理了多少，对于静态页面，处理多少次都没有关系，但是对于有些情况，比如 POST 数据，就有多次下单的风险，所以都会发起询问，要再次确认  


### 第 5 章 Web 服务器  

服务器完成的任务：建立连接、接收请求、处理请求、访问资源、构建响应、发送相应、记录日志  

服务器是可以存储的，就是相当于电脑磁盘，只是没有写入数据库而已  
在 django/core/handlers/wsgi.py 中看到了 buffer size = 64 \* 1024 \* 1024 就是 64 个 G  

Web 服务器会解析请求报文，包括查找请求方法，查找指定资源  

对资源的映射及访问，就是 Nginx 里 root 和 alias 所做的事；GET 后面接的是相对位置，所以 root 和 alias 做的是把路径补全  


### 第 6 章 代理  

Web 代理(proxy) 位于客户端和服务器之间，代理既是服务器又是客户端，如果没有代理，客户端就要和服务器直接进行对话  

代理是同一种协议，网关则是将不同的协议连接起来  

为什么要使用代理：内容过滤器、安全防火墙、Web 缓存、方向代理等  

TRACE 可以追踪链路，对于代理流的调试非常有用  

Via 首部  



### 第 7 章 缓存  

Web 缓存可以自动保存常见文档副本  

速度快、减少重复流量、缓解宽带瓶颈、减轻服务器负担、  

304 Not Modified 内容没有变，可以直接应用缓存  

缓存分为私有缓存和公共缓存  

缓存又叫临时文件  

Web 缓存的基本工作原理大多非常简单：  
1. 接收 HTTP 请求报文；  
2. 对报文进行解析，提取 URL 和各种首部；  
3. 查询是否有副本可用，如果没有就获取副本；  
4. 查看已有缓存是否过期，如果没过期，就向服务器查询是否有更改；
5. 用新的首部和缓存主体创建响应；
6. 将响应发回客户端；
7. 创建日志   


缓存数据要保证和原服务器内容完全一样  

Cache-Control:max-age 使用的是相对时间  

Expire 和上面是一样的，只是用的是绝对时间；不推荐使用，因为很多服务器时间不同步  

If-Modified-Since，如果没有修改，返回 304 Not Modified  

使用 Cache-Control 加不同的参数，控制缓存能力  


### 第 8 章 集成点：网关、隧道及中继  

网关：HTTP 的发展是用户需求驱动的，当要在 Web 获得更复杂的资源的时候，人们很快发现，单个应用程序无法处理所有这些想要的资源。为了解决这个问题，开发者提出了网关(gateway)的概念，网关可以作为某种翻译器使用，在 HTTP 和其他协议之间起到接口作用。这样 HTTP 客户端无需了解其他协议，就可以和其他应用程序进行交互。  


Web 网关一侧使用 HTTP 协议，一侧使用其他协议  

API Application Programming Interface 应用编程接口  

CGI Common Gateway Interface 通用网关接口  

WSGI Python Web Server Gateway Interface 这个就是说两边用的协议不一样  

Web 隧道，可以通过 HTTP 应用程序访问非 HTTP 协议的应用程序，允许用户通过 HTTP 连接发送非 HTTP 流量，可以穿过防火墙  


中继(relay)是没有完全遵循 HTTP 规范的简单 HTTP 代理  


### Web 机器人  

无需人类干预可以自动进行一系列 Web 事务处理的软件程序  

爬虫  

爬虫开始访问的 URL 初始集合被称为根集(root set)  

机器人和其他 HTTP 客户端并没有什么区别  

建议机器人发送一些基本的首部信息  

robots.txt 说明了可以访问哪些部分，是一种简单的自愿约束技术  


### 第 11 章 客户端识别和 cookie 机制  

cookie 就是保存在浏览器端的键值对  

个性化接触，需要知道客户端的信息。  

个性推荐、用户管理  

User-Agent 首部可以将用户所用浏览器相关信息告知服务器，包括程序名称和和版本，通常还包括操作系统相关信息，从而可以有更好的交互。是非常有用的  

Referer 提供了用户来源页面 URL  

NAT Network Address Translation 网络地址转换的防火墙，隐藏了真实的 IP 地址，将实际 IP 地址转换成了一个共享的防火墙 IP 地址和不同的端口号  

Authentication 首部  

cookie 就像是给用户后背贴一张贴纸，再次访问站点的时候，Web 站点就可以读取贴纸上的信息  

通过 Set-Cookie 实现贴纸  

cookie 的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器时都将这些信息提供给它  

在 console 控制台输入：document.cookie 查看 cookie，其实和 header 上看到的是一样的，在本地就是一个简单的 sqlite 文件  

对不同的网站发送不同的 cookie，domain 参数指定了可以发送该 cookie 的网站  

Expire 指定了生存的日期  

Secure 只有使用 SSL 时才能发送 cookie  


### 第 12 章 基本认证机制  

认证就是要证明你是谁，通常是通过用户名和密码来进行认证  

WWW-Authenticate  

Authorization  

Authentication-Info   


### 第 13 章 摘要认证  

MD5  


### 第 14 章 安全 HTTP  

安全就是保险箱  

HTTPS  

加密之前的原始报文被称为明文，使用了密码之后的编码报文被称为密文  



### 第 15 章 实体和编码  

报文是快递单，实体就是包裹  

实体首部  

Content-Type  

Content-Length，没有 Content-Length HTTP 应用程序就不知道实体主体在哪里结束，下一条报文从哪里开始    

Content-Language  

Content-Encoding，告诉我们数据是不是已被要说或者重编码；gzip 以后更小；gzip 就是 GUN zip，使用最广泛，是无损压缩，减少传输大小，没有内容损失  

为了避免服务器发送的编码客户端不支持，客户端需要将自己支持的编码方式放在 Accept-Encoding 中  

Last-Modified  

Allow  

Expire，过了过期时间以后，就不应当认为它还是最新的    


使用表单 POST 的时候，使用 Content-Type：application/x-www-form-urlencoded 首部，上传文件使用 Content-Type：multipart/from-data 首部  

Transfer-Encoding：chunked 分块  

有条件的请求通过 If 开头的首部来实现  

ETag 文档每个实例的唯一标识符，由服务器在响应中发送，客户端在后继请求的 If-Match 和 If-None-Match 首部中使用它  

[编码：ASCII、Unicode、UTF-8、GBK 的区别](https://mp.weixin.qq.com/s?__biz=MzA5NzgzODI5NA==&mid=2454037080&idx=3&sn=fa5c1437db40ae0fad57a4ec31f97524&chksm=872bb7e1b05c3ef71984b33f38635f5cb4592187a11ffbfacc044b5fb4ca8a1f64938ddfbed6&scene=21#wechat_redirect)  


### 第 16 章 国际化  

HTTP 报文可以承载任何语言的内容，就像可以承载文本、图像、影片等类型一样。对 HTTP 来说，实体主体只是二进制内容而已  

服务器通过 Content-Type 首部中的 charset 和 Content-Language 首部告知客户端  

客户端发送 Accept-Charset 和 Accept-Language  

charset 会将二进制内容解码成指定字符  

先把二进制码转换成字符代码，比如 0011010100 转换成 64 203 227 等，然后根据 charset 将数字同字符集对照，拿出指定的字符，比如 64 对应 A，227 对应空格等  


### 第 17 章 内容协商与转码  

向英语用户发送英文版，向法语用户发送法语版，单一 URL 可以代表不同的资源，用的就是内容协商方法  

手持设备把 HTML 页面转换成 WML 页面，这种动态内容变换被称为转码  


### 第 18 章 Web 主机托管  


### 第 19 章 发布系统  


### 第 20 章 重定向与负载均衡  

重定向技术可以将报文发送到客户端没有显式请求的地方去  

Web 内容通常分布在很多地方，一个地方出问题了，其他地方还可以用，提高了可靠性，所以就有了重定向  

请求倾向于访问较近的资源，降低访问时间；将目标服务器分散，可以减少网络拥塞。  

可以将重定向当作是有助于找到最佳分布式内容的技术。   


重定向和负载均衡是共存的，大多数重定向部署都包含了某些形式的负载均衡，也就是说，它们可以将报文的负载分摊到一组服务器中去  

服务器、代理、缓存和网关对客户端来说都是服务器  



最常见的也是最简单的重定向技术之一就是 DNS 轮转，这是一种单纯的负载均衡策略，没有考虑客户端和服务器的相对位置，也没有考虑服务器的负载情况  


PCA 就是以自动配置方式动态地配置浏览器，使其连接到正确的代理服务器上去，是个 JavaScript 文件，功能强大  




### 第 21 章 日志记录和使用情况追踪  

几乎所有的服务器和代理服务器都会记录下他们所处理的 HTTP 事务摘要，可以用来：跟踪使用情况、安全性、计费、错误检测等等  


大多数情况下，日志记录处于两种原因：查找服务器的问题如哪些请求失败了，或者是生成 Web 站点访问方式的统计信息，这些数据对市场营销、计费和容量规划都非常有用  

常见日志格式，就是 Django 后台 runserver 以后动态显示的内容，包括时间、请求方法、状态码等等  



### 附录  

附录有状态码和各种首部的详细介绍  







