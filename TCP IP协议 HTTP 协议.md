
# 有时间去读原版 RFC，一劳永逸解决问题  


记笔记原则是，一般而言每章记不超过 5 个知识点，多了就没有意义了  


# TCP/IP 协议  

IP 是主机之间的通信，TCP 是进程之间的通信  
IP Internet Protocol 网络层  
TCP Transmission Control Protocol 传输控制协议，传输层  

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。  

TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。  


### 三次握手四次挥手 

#### 三次握手
第一次握手：客户端向服务器发送 TCP 连接请求，其中标志 SYN=1，序列号为客户端初始序列号 client_isn，客户端进入 SYN_SEND 状态，等待服务器的确认；  
第二次握手：服务器收到请求后，返回一个应答，其中标志 SYN=1，ACK=1，序列号为服务器初始序列号 server_isn，确认号为客户端初始序列号加 1，即 client_isn+1；此时服务器进入 SYN_RECV 状态；  
第三次握手：客户端再向服务器发送一个确认报文，其中标志 ACK=1。序列号为客户端初始序列号加 1，即 client_isn+1，确认号为服务器初始序列号加 1，即 server_isn+1，客户端和服务器端都进入 ESTABLISHED 状态。  
经过上述 3 次握手后，TCP 连接正式建立。  
(序列号是自己的，确认号是对方的，要发送的确认号=已收到的序列号+已收到数据的字节数)  

#### 四次挥手
第一次挥手：客户端向服务器发送一个 FIN 段，主动关闭客户端到服务器的数据传输，客户端进入 FIN_WAIT_1 状态；  
第二次挥手：服务器收到客户端发送的 FIN 段后，向应用程序发送一个文件结束符，再向客户端发回一个 ACK 段，服务器进入 CLOSE_WAIT 状态，客户端收到 ACK 段后，进入 FIN_WAIT_2 状态；  
第三次挥手：服务器向客户端发送 FIN 段，服务器进入 LAST_ACK 状态；  
第四次挥手：客户端收到服务器发送的 FIN 段，向服务器发回一个 ACK 段，以证实从服务器收到了 FIN 段，然后客户端进入 TIME_WAIT 状态；服务器收到客户端发送的 ACK 段后，关闭连接；客户端等待 2 个 MSL 后，关闭连接。  


#### 为什么要三次握手
client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”


#### 四次挥手  

TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是全双工模式，这就意味着，当客户端发出 FIN 报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务器的数据；当服务器返回 ACK 报文段时，表示它已经知道客户端没有数据发送了，但是服务器还是可以发送数据到客户端的；当服务器也发送了 FIN 报文段时，这个时候就表示服务器也没有数据要发送了。  


#### 为什么要等待 2MSL  
网络并不总是可靠的，如果客户端发送的 ACK 段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 段。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。  



读 60 遍 &emsp; 50/60  


《TCP-IP 协议及其应用》 TCP 章听 5 遍 完成 1 遍  
《网络是怎么连接的》 TCP 章听 5 遍  

sequence number 解决乱序问题  
acknowledgement number 解决丢包问题  
是通过这两个还有校验和来保证传输的可靠性的  

URG，不用在缓存区保留，直接传至对方  


## 《TCP/IP 协议及其应用》  这本书读目录；多听，听一遍也就一个小时多一点；最主要的学习方法是遇到了来查  

TCP/IP 协议是目前最完整的、被普遍接受的通信协议标准，无论是局域网还是广域网，TCP/IP 协议都是使用最为广泛的网络协议。  

### 第 1 章 TCP/IP 协议基础  

RFC Request For Comment，是关于 Internet 的一系列注解和文件，是学习和掌握 Internet 知识的最重要的资料。  

看似是对等层交流，本质上还是通过物理通信的  

ARP Adress Resolution Protocol 用于根据 IP 地址获取物理地址  

每台主机都有一个唯一的 IP 地址  

TCP 和 UDP 协议使用端口号来识别应用程序  

排查网络问题的第一步常常是使用 ping 命令来测试网络的连通性。  



### 第 2 章 网络接口层 
最终传输的是电信号  

MAC Media Access Control 介质访问控制  

在生产网卡时，MAC 地址已经被固化在网卡的只读存储器(ROM)中，因此 MAC 地址也常常被称为硬件地址或物理地址。  

MTU Maximum Transmit Unit 最大传输单元  


### 第 3 章 IP 寻址和地址解析(再听一遍，只听这一章)  

IP 地址在网络层实现了底层网络地址的统一，使 TCP/IP 网络层地址具有全局唯一性和一致性  

IP 地址是 32 位二进制数字，一般分为 4 个 8 位字段，以 4 个十进制数字表示，每个数字用点隔开。比如 8.131.249.249  

IP 地址采用由网络 ID 和主机 ID 组成的两级结构  



### 第 4 章 IP 协议  

IP 协议 Internet Protocol  

Packet 包或数据包，是在网络上传送的任一数据单位，容量可大可小。  

IP 协议涉及两个基本功能：寻址和分片  

IP 协议是无连接的、不可靠的、点对点的协议，只能尽力(Best Effort)传输数据  

如果要增加可靠性，就要再上面使用 TCP 协议  

IP 协议效率非常高，实现起来也比较简单，就是因为采用了尽力传输的思想  

IP 报文  

#### 4.3 数据分片和重组  
因为底层网络不能封装大的数据包，所以要对数据进行分装和重组(所以报文中很多都是围绕实现分装和重组功能设置的，比如序号、校验和等等)  

底层物理网络能够封装的最大数据长度称为该网络的最大传输单元(Maximum Transmission Unit, MTU)  

分片就是将一个数据报划分成若干更小的单元，以适应底层物理网络的 MTU。  

由于各分片独立传输，到达目的主机的顺序无法保证，需要分片字段为重组提供顺序信息  

IP 协议主要依据数据报首部中的标识、标志和分片偏移字段进行分片重组  


### 第 7 章 传输层协议 TCP 与 UDP  

TCP Transmission Control Protocol 传输控制协议  
UDP User Datagram Protocol 用户数据报协议  

创建进程到进程的通信  

TCP 协议的特性：面向连接、全双工、可靠、基于字节流；效率不高，占用资源较多  

TCP 和 UDP 采用协议端口来标识某一主机的通信进程  



MD5 全称 Message-Digest Algorithm 5，报文摘要算法第 5 版  




# HTTP 协议  

### 第 1 章 HTTP 概述  

Web 浏览器、服务器和相关的 Web 应用程序都是通过 HTTP 相互通信的。HTTP 是现代全球互联网中使用的公共语言。  

HTTP 使用的是可靠的数据传输协议  

Web 内容都是存储在 Web 服务器上的，Web 服务器是 Web 资源的宿主  

媒体类型 MIME Multipurpose Internet Mail Extension 多用途因特网邮件拓展  

Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型  

每个 Web 服务器资源都有一个名字，这样客户端就能找到特定的资源了。服务器资源名称被称为统一资源标识符(Uniform Resource Identifier URI)。(urls.py 和 views.py 就是为资源指定地址)  

给定了 URI，HTTP 就可以解析出对象  

**URL 就是找资源用的，就是资源地址**

统一资源定位符(URL)描述了一台特定服务器上某资源的特定位置，可以明确说明如何从一个精确、固定的位置获取资源(比如 course detail 和 blog detail 的 ?id，找的就是特定的资源，? 是查询，比如分类)  

请求 request，说明要找的资源是什么，比如 GET /logo.gif HTTP/1.1，response 就是展示出图片   

每条报文都包含一个方法，方法会告诉服务器执行什么操作。常用方法：GET、POST、PUT、DELETE  

GET 从服务器取资源  

POST 从客户端向服务器发送要处理的数据  

PUT 将请求的主体部分存储在服务器上  

每条报文都会携带一个状态码  

一个 HTTP 事务由一条客户端发向服务器的请求命令和一个从服务器发回客户端的响应结果组成。  

应用程序完成一项任务通常会发布多个 HTTP 事务，这些资源可能都不在一个服务器上。(Nginx 静态文件，uwsgi 动态文件)  

HTTP 是基于 TCP 的，TCP 连接是可靠的传输协议  

TCP 连接需要指导 IP 地址和服务器上运行的特定软件的端口号。(端口号的作用是用来找应用程序的，这就是阿里云安全组的意义，也是 Nginx 配置端口号的意义)  

怎么知道 IP 地址和端口号呢？当然是通过 URL 了，URL 就是资源地址  

没有端口号的时候，是 80 端口，所以还是有端口的；有了 IP 有了端口，本质上还是建立 TCP 连接  

Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此 TCP 端口的输出送回到显示屏上。可以通过 Telnet 程序直接与 Web 服务器进行对话，Web 服务器会将 Telnet 程序作为一个 Web 客户端来处理，所有送回 TCP 连接的数据都会显示在屏幕上  

Telnet 可以很好地模拟客户端  

##### 代理  

代理位于客户端和服务器之间，接受所有客户端的 HTTP 请求，并将这些请求转发给服务器，代表用户访问服务器   

##### 缓存  

Web 缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以使用缓存副本提供的服务了；使用客户端附近的缓存要比从远程 Web 服务器快得多  

##### 网关  

网关(gateway) 是一种特殊的服务器，常用于将 HTTP 流量转换成其他的协议，客户端可能并不知道自己正在和一个网关进行通信。  

比如客户端发送 HTTP 请求到网关，网关向 FTP 服务器发送 FTP 请求，FTP 发回文件，网关将其封装成 HTTP 报文，发送给客户端  



### 第 2 章 URL 与资源  

URL 就是资源位置  

scheme、主机和资源路径  

URL 路径说明了资源位于服务器的什么地方，本质上就是服务器的文件系统路径  


### 第 3 章 HTTP 报文  

理解了报文就可以编写自己的 HTTP 应用程序  

就是 start line、header、body  

Content-Type 说明了 body 是什么格式，比如 text/html  

Content-Length 说明了 body 的大小，单位是字节    

请求报文起始行说明了要做什么，响应报文起始行说明发生了什么  

请求要指明 HTTP 版本号，以便互相了解对方的能力和报文格式  

首部分为通用首部(既可以出现在请求报文中，也可以出现在响应报文中)、请求首部(请求特有的，提供更多请求的信息，比如 accept 首部)、响应首部(响应特有的，提供更多有关响应的信息)  

主体 body 是 HTTP 要传输的内容，类型包括：图片、视频、HTML文档等  

GET 方法是最常用的方法，通常用于请求服务器发送某个资源  

HEAD 方法只返回首部，不返回 body  

PUT 方法向服务器写入文档，比如 PUT /a.txt HTTP/1.1 会返回 201 created  

POST 起初是用来想服务器输入数据的(POST 用于向服务器发送数据，PUT 用于向服务器上的资源比如文件中存储数据)，现在通常用来支持 HTML 表单  

TRACE 可以看中间经历过程，比如代理等  


状态码提供了一种理解处理结果的便捷方式  

100-199 信息性状态码  

200-299 成功状态码  

300-399 重定向状态码  

400-499 客户端错误状态码  

500-599 服务器错误状态码  

404 错误是最常见的错误，请求的是一个不存在的 URL  


通用首部，比如时间 Date    

Greenwich Mean Time(GMT)格林威治时间，北京时间=GMT+8  

Cache-Control 缓存指示  

请求首部，说明是谁或什么在发送请求，请求源自何处，或者客户端可以接受的格式，服务器可以根据这些提供更好的响应  

Accept 首部，对客户端和服务器都是有益的，服务器不用浪费时间发送无用的格式；比如 Accept-Charset、Accept-Encoding、Accept-Language  

HOST 是要请求的服务器的 IP 和端口  

响应首部，有助于客户端处理响应，并在将来发送更好的请求  

Server 服务器应用程序软件名称和版本，比如访问自己的网站的时候，Server 是 nginx/1.18.0 (Ubuntu)，说明浏览器确实是在和 Nginx 交互的，Nginx 在 uwsgi 前面  


实体首部，实体首部提供了有关实体及其内容的大量信息  

Content-Length、Content-Type、Content-Encoding  


### 第 4 章 连接管理  

客户端可以通过 TCP/IP 连接到世界上任何地方的服务器应用程序，而且是可靠的连接，不会有报文丢失  

先将 IP 地址和端口号从 URL 中分离出来，然后建立 TCP 连接，然后发送一条 GET 报文，收到响应，关闭连接  

HTTP 连接实际上就是 TCP 连接及其使用规则  

Connection：keep-alive 事务结束以后 TCP 依然保持连接，不用每次都再握手连接  


有时连接中间关闭，事务没有处理完，客户端无法确认处理了多少，对于静态页面，处理多少次都没有关系，但是对于有些情况，比如 POST 数据，就有多次下单的风险，所以都会发起询问，要再次确认  

### 第 5 章 Web 服务器  

服务器完成的任务：建立连接、接收请求、处理请求、访问资源、构建响应、发送相应、记录日志  

服务器是可以存储的，就是相当于电脑磁盘，只是没有写入数据库而已  

Web 服务器会解析请求报文，包括查找请求方法，查找指定资源  

对资源的映射及访问，就是 Nginx 里 root 和 alias 所做的事；GET 后面接的是相对位置，所以 root 和 alias 做的是把路径补全  


### 第 6 章 代理  

Web 代理(proxy) 位于客户端和服务器之间，代理既是服务器又是客户端，如果没有代理，客户端就要和服务器直接进行对话  

代理是同一种协议，网关则是将不同的协议连接起来  

为什么要使用代理：内容过滤器、安全防火墙、Web 缓存、方向代理等  

TRACE 可以追踪链路，对于代理流的调试非常有用  

via 首部  

OPTIONS 返回 Allow 首部，显示服务器支持的方法  


### 第 7 章 缓存  

Web 缓存可以自动保存常见文档副本  

速度快、减少重复流量、缓解宽带瓶颈、减轻服务器负担、  

304 Not Modified 内容没有变，可以直接应用缓存  

缓存分为私有缓存和公共缓存  

缓存又叫临时文件  

Web 缓存的基本工作原理大多非常简单：(1)接收 HTTP 请求报文；(2)对报文进行解析，提取 URL 和各种首部；(3)查询是否有副本可用，如果没有就获取副本；(4)查看已有缓存是否过期，如果没过期，就向服务器查询是否有更改；(5)用新的首部和缓存主体创建响应；(6)将响应发回客户端；(7)创建日志   

缓存数据要保证和原服务器内容完全一样  

Cache-Control:max-age 使用的是相对时间  

Expire 和上面是一样的，只是用的是绝对时间；不推荐使用，因为很多服务器时间不同步  

If-Modified-Since，如果没有修改，返回 304 Not Modified  

使用 Cache-Control 加不同的参数，控制缓存能力  


### 第 8 章 集成点：网关、隧道及中继  

网关：HTTP 的发展是用户需求驱动的，当要在 Web 获得更复杂的资源的时候，人们很快发现，单个应用程序无法处理所有这些想要的资源。为了解决这个问题，开发者提出了网关(gateway)的概念，网关可以作为某种翻译器使用，在 HTTP 和其他协议之间起到接口作用。这样 HTTP 客户端无需了解其他协议，就可以和其他应用程序进行交互。  

























