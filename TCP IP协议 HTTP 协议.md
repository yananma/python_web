
# 有时间去读原版 RFC，一劳永逸解决问题  


记笔记原则是，一般而言每章记不超过 5 个知识点，多了就没有意义了  


# TCP/IP 协议  

IP 是主机之间的通信，TCP 是进程之间的通信  
IP Internet Protocol 网络层  
TCP Transmission Control Protocol 传输控制协议，传输层  

TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。  

TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。  


### 三次握手四次挥手 

#### 三次握手
第一次握手：客户端向服务器发送 TCP 连接请求，其中标志 SYN=1，序列号为客户端初始序列号 client_isn，客户端进入 SYN_SEND 状态，等待服务器的确认；  
第二次握手：服务器收到请求后，返回一个应答，其中标志 SYN=1，ACK=1，序列号为服务器初始序列号 server_isn，确认号为客户端初始序列号加 1，即 client_isn+1；此时服务器进入 SYN_RECV 状态；  
第三次握手：客户端再向服务器发送一个确认报文，其中标志 ACK=1。序列号为客户端初始序列号加 1，即 client_isn+1，确认号为服务器初始序列号加 1，即 server_isn+1，客户端和服务器端都进入 ESTABLISHED 状态。  
经过上述 3 次握手后，TCP 连接正式建立。  
(序列号是自己的，确认号是对方的，要发送的确认号=已收到的序列号+已收到数据的字节数)  

#### 四次挥手
第一次挥手：客户端向服务器发送一个 FIN 段，主动关闭客户端到服务器的数据传输，客户端进入 FIN_WAIT_1 状态；  
第二次挥手：服务器收到客户端发送的 FIN 段后，向应用程序发送一个文件结束符，再向客户端发回一个 ACK 段，服务器进入 CLOSE_WAIT 状态，客户端收到 ACK 段后，进入 FIN_WAIT_2 状态；  
第三次挥手：服务器向客户端发送 FIN 段，服务器进入 LAST_ACK 状态；  
第四次挥手：客户端收到服务器发送的 FIN 段，向服务器发回一个 ACK 段，以证实从服务器收到了 FIN 段，然后客户端进入 TIME_WAIT 状态；服务器收到客户端发送的 ACK 段后，关闭连接；客户端等待 2 个 MSL 后，关闭连接。  


#### 为什么要三次握手
client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”


#### 四次挥手  

TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是全双工模式，这就意味着，当客户端发出 FIN 报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务器的数据；当服务器返回 ACK 报文段时，表示它已经知道客户端没有数据发送了，但是服务器还是可以发送数据到客户端的；当服务器也发送了 FIN 报文段时，这个时候就表示服务器也没有数据要发送了。  


#### 为什么要等待 2MSL  
网络并不总是可靠的，如果客户端发送的 ACK 段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 段。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。  



读 60 遍 &emsp; 50/60  


《TCP-IP 协议及其应用》 TCP 章听 5 遍 完成 1 遍  
《网络是怎么连接的》 TCP 章听 5 遍  

sequence number 解决乱序问题  
acknowledgement number 解决丢包问题  
是通过这两个还有校验和来保证传输的可靠性的  

URG，不用在缓存区保留，直接传至对方  


## 《TCP/IP 协议及其应用》  这本书读目录；多听，听一遍也就一个小时多一点；最主要的学习方法是遇到了来查  

TCP/IP 协议是目前最完整的、被普遍接受的通信协议标准，无论是局域网还是广域网，TCP/IP 协议都是使用最为广泛的网络协议。  

### 第 1 章 TCP/IP 协议基础  

RFC Request For Comment，是关于 Internet 的一系列注解和文件，是学习和掌握 Internet 知识的最重要的资料。  

看似是对等层交流，本质上还是通过物理通信的  

ARP Adress Resolution Protocol 用于根据 IP 地址获取物理地址  

每台主机都有一个唯一的 IP 地址  

TCP 和 UDP 协议使用端口号来识别应用程序  

排查网络问题的第一步常常是使用 ping 命令来测试网络的连通性。  



### 第 2 章 网络接口层 
最终传输的是电信号  

MAC Media Access Control 介质访问控制  

在生产网卡时，MAC 地址已经被固化在网卡的只读存储器(ROM)中，因此 MAC 地址也常常被称为硬件地址或物理地址。  

MTU Maximum Transmit Unit 最大传输单元  


### 第 3 章 IP 寻址和地址解析(再听一遍，只听这一章)  

IP 地址在网络层实现了底层网络地址的统一，使 TCP/IP 网络层地址具有全局唯一性和一致性  

IP 地址是 32 位二进制数字，一般分为 4 个 8 位字段，以 4 个十进制数字表示，每个数字用点隔开。比如 8.131.249.249  

IP 地址采用由网络 ID 和主机 ID 组成的两级结构  



### 第 4 章 IP 协议  

IP 协议 Internet Protocol  

Packet 包或数据包，是在网络上传送的任一数据单位，容量可大可小。  

IP 协议涉及两个基本功能：寻址和分片  

IP 协议是无连接的、不可靠的、点对点的协议，只能尽力(Best Effort)传输数据  

如果要增加可靠性，就要再上面使用 TCP 协议  

IP 协议效率非常高，实现起来也比较简单，就是因为采用了尽力传输的思想  

IP 报文  

#### 4.3 数据分片和重组  
因为底层网络不能封装大的数据包，所以要对数据进行分装和重组(所以报文中很多都是围绕实现分装和重组功能设置的，比如序号、校验和等等)  

底层物理网络能够封装的最大数据长度称为该网络的最大传输单元(Maximum Transmission Unit, MTU)  

分片就是将一个数据报划分成若干更小的单元，以适应底层物理网络的 MTU。  

由于各分片独立传输，到达目的主机的顺序无法保证，需要分片字段为重组提供顺序信息  

IP 协议主要依据数据报首部中的标识、标志和分片偏移字段进行分片重组  


### 第 7 章 传输层协议 TCP 与 UDP  

TCP Transmission Control Protocol 传输控制协议  
UDP User Datagram Protocol 用户数据报协议  

创建进程到进程的通信  

TCP 协议的特性：面向连接、全双工、可靠、基于字节流；效率不高，占用资源较多  

TCP 和 UDP 采用协议端口来标识某一主机的通信进程  







# HTTP 协议  

### 第 1 章 HTTP 概述  

Web 浏览器、服务器和相关的 Web 应用程序都是通过 HTTP 相互通信的。HTTP 是现代全球互联网中使用的公共语言。  

HTTP 使用的是可靠的数据传输协议  

Web 内容都是存储在 Web 服务器上的。  

Web 服务器是 Web 资源的宿主  

媒体类型 MIME Multipurpose Internet Mail Extension 多用途因特网邮件拓展  

Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型  

每个 Web 服务器资源都有一个名字，这样客户端就能找到特定的资源了。服务器资源名称被称为统一资源标识符(Uniform Resource Identifier URI)。(urls.py 和 views.py 就是为资源指定地址)  

给定了 URI，HTTP 就可以解析出对象  

**URL 就是找资源用的，就是地址**

统一资源定位符(URL)描述了一台特定服务器上某资源的特定位置，可以明确说明如何从一个精确、固定的位置获取资源(比如 course detail 和 blog detail 的 ?id，找的就是特定的资源)  

请求 request，说明要找的资源是什么，比如 GET /logo.gif HTTP/1.1，response 就是展示出图片   

每条报文都包含一个方法，方法会告诉服务器执行什么操作。常用方法：GET、POST、PUT、DELETE  

GET 从服务器取资源  

POST 从客户端向服务器发送数据  

每条报文都会携带一个状态码  

一个 HTTP 事务由一条客户端发向服务器的请求命令和一个从服务器发回客户端的响应结果组成。  

应用程序完成一项任务通常会发布多个 HTTP 事务，这些资源可能都不在一个服务器上。(Nginx 静态文件，uwsgi 动态文件)  

HTTP 是基于 TCP 的，TCP 连接是可靠的传输协议  

TCP 连接需要指导 IP 地址和服务器上运行的特定软件的端口号。(端口号的作用是用来找应用程序的，这就是阿里云安全组的意义，也是 Nginx 配置端口号的意义)  

怎么知道 IP 地址和端口号呢？当然是通过 URL 了，URL 就是资源地址  

没有端口号的时候，是 80 端口，所以还是有端口的；有了 IP 有了端口，本质上还是建立 TCP 连接  

Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此 TCP 端口的输出送回到显示屏上。可以通过 Telnet 程序直接与 Web 服务器进行对话，Web 服务器会将 Telnet 程序作为一个 Web 客户端来处理，所有送回 TCP 连接的数据都会显示在屏幕上  

Telnet 可以很好地模拟客户端  

##### 代理  

代理位于客户端和服务器之间，接受所有客户端的 HTTP 请求，并将这些请求转发给服务器，代表用户访问服务器   

##### 缓存  

Web 缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以使用缓存副本提供的服务了；使用客户端附近的缓存要比从远程 Web 服务器快得多  

##### 网关  

网关(gateway) 是一种特殊的服务器，常用于将 HTTP 流量转换成其他的协议，客户端可能并不知道自己正在和一个网关进行通信。  

比如客户端发送 HTTP 请求到网关，网关向 FTP 服务器发送 FTP 请求，FTP 发回文件，网关将其封装成 HTTP 报文，发送给客户端  
























