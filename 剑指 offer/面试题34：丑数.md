
题目描述  
把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。  

解题思路  
首先明确一下丑数的定义：只包含因子 2，3 和 5 的数。所以要判断一个数是否是丑数，可以先用它除以 2（如果它 %2 为 0，则把它除以 2，循环判断和除），除以 3，除以 5，这一套下来如果最后只剩 1，说明它是丑数。  

既然能够判断丑数，最笨的方法就是从 1 开始挨个往后找，直到找到第 N 个丑数。缺点：每个数都判断了一次，但是有的数肯定不是丑数，还是花费大量时间去判断了。  

根据定义，除了 1 之外，丑数应当是另一个丑数乘以 2 或 3 或 5 的结果，所以可以保存之前已求出的丑数，用来生成后续的丑数。  

理一下思路。有一个数组，按大小存放当前已经找到的丑数。假设当前数组中最大的丑数是 M。要找一个新的丑数，肯定是根据列表中当前的数 x2/3/5 生成出来的。把每个丑数乘以 2，然后选第一个大于 M 的；把每个乘以 3，然后选第一个大于 M 的；把每个乘以 5，然后选第一个大于 M 的。从这三个结果中，选出最小的那个，就是下一个找到的丑数。  

由于列表有序，不必从头把每个数乘以 2，只要记下第一个乘以 2 之后大于 M 的位置即可，后面再找，可以从该位置继续往后找。所以可以使用 3 个标记指针，以代表 x2 的指针为例，x2 指针指向当前第一个 x2 之后大于 M 的数，同理 x3 和 x5 指针也是。  


```python 
# -*- coding:utf-8 -*-
class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index < 1:
            return 0
        arr = [1, ]
        p2 = p3 = p5 = 0
        while len(arr) < index:
            if arr[-1] == arr[p2] * 2:
                p2 += 1
            if arr[-1] == arr[p3] * 3:
                p3 += 1
            if arr[-1] == arr[p5] * 5:
                p5 += 1
            arr.append(min(arr[p2]*2, arr[p3]*3, arr[p5]*5))  
        return arr[-1]
```
